#!/usr/bin/env python3
# -*- coding: utf-8 -*-


"""
字符串：
	字符集上有的确定的序关系 -- 字符序列
	数学的小于表示排在前面
	
	字符串考虑的是整体的操作和处理
	
	字符串的相关概念：
		长度：字符的个数，任意字符集中只有唯一的一个空串
		位置：下标，从0开始
		相等：长度，内容完全相同
		字典序：
		不同长度，前面相同，长的大
		字符串拼接：python中使用+号
		子串关系：子串与父串有相同的部分即可
		前缀和后缀：
		！！！注意空串的特殊性
	
	字符串之间有结合律，但没有交换律
	
	字符串看成不变数据类型：
		字符串内容存储：
			存储在一块大的连续区间
			每个字符单独存储
			分段存储
		串结束：
			单独记录长度
			用特殊编码结束
	字符串的替换：
		多次操作完成整个替换
		重叠部分：规定从左到右
		替换后再有重叠的部分应该不要动
		无法预知需要替换部分的个数
	
	
	不同语言中字符串之间的差异：
		字符串可变可不变	python中为不变
		是否有独立的字符类型，python中没有
		基本字符集：python为Unicode
		
		
	python的字符串：
		str -- 不变类型
		长度 -- 其他信息 -- 字符存储区
		
		str的操作：
			获取信息
			构造新str对象
			
		str构造操作：
			简单操作：求长，定位访问
			扫描整个串：O(n)
			
		字符串替换：
			对整个字符串匹配，确定需要匹配的字串的次数和相应的位置
			构造新串过程中动态调整大小
	
	
	字符串匹配：
		模式串 -- 目标串
		
		实际的串匹配问题：
			文本内容大
			模式串大
			时间要求高
			模式串多
	
		串匹配算法：
			逻辑判断
			关键点：
				怎样开始比较字符串
				不匹配后如何操作
				
		
		朴素匹配法：
			从左到右匹配
			发现不匹配，从下一个点开始
			
		KMP算法：
			提前记录字符串的匹配信息 -- 静态预处理
	
	字符串匹配问题：
		模式：
			模式的形式是什么；
			描述的字符串集合如何确定
			怎样做匹配
			
		模式语言 -- 正则表达式（regex）
		
	
	正则表达式：
		原始字符串：在不同字符串前加r或R前缀，反斜杠不作为转义字符
		
	python中re模块的使用：
		re.compile(pattern, flag=0)  -- 生成匹配模式  -- 当一个模式匹配使用的次数多时，则如此操作
		# 直接生成一个正则表达式对象
		
		re.search(patter, string, flag=0) -- 从任意位置开始匹配，值匹配一次）
		
		re.match(patter, string, flag=0) -- 从头开始匹配，从头开始匹配，仅匹配一次
		
		re.split(pattern, string, maxsplit=(), flags=()) -- 分割字符串，maxsplit最大分割数
		
		re.findall(pattern, string, flags=0) -- 返回一个列表，匹配所有
		
		[\t \v\n\f\r] -- 空白字符
		
		"\^","\-","\]"
	
	模式串中：
		圆括号 -- 表示组
		圆点 .   -- 表示任意字符
		
	使用括号来确定作用空间
	
	python中将'-'看作运算符，非0整数不以0开头
	
	行首描述符，是与每一行的行首匹配，不一定只针对字符串行首
	
	使用r不转义
	
	当匹配失败时，会返回None
		
	mat.group()		# 获取匹配到的字符串
	mat.strat()		# 获取取匹配到的字符串的起始索引位置
	mat.end()
	
	mat.span()		# 字符串位置区间
	
	mat.re		# 查看匹配规则
	mat.string		# 查看被匹配的字符串
	
	通过mat.group(n) 	# 获取相应的组元素，通过括号设定相应的组范围
	
	同时，通过在模式串中使用 '\n' 表示第n个匹配的串；但要注意格式的
	
	re.sub(pattern, repl, string, count=0, flags=0)
	
	
	### TODO ###
		--str
			--package1
				--program1.py 
				# 从program1中调用program2
				# 这时，会显示program2中的 from program3 import ... 出现错误
				# 表示未找到相应的module
			--package2
				--program2.py # 在program2中调用了program3(from program3 import ..)
				--program3.py	
"""