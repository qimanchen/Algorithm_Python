#!/usr/bin/env python3
# -*- coding: utf-8 -*-


"""
字符串：
	字符集上有的确定的序关系 -- 字符序列
	数学的小于表示排在前面
	
	字符串考虑的是整体的操作和处理
	
	字符串的相关概念：
		长度：字符的个数，任意字符集中只有唯一的一个空串
		位置：下标，从0开始
		相等：长度，内容完全相同
		字典序：
		不同长度，前面相同，长的大
		字符串拼接：python中使用+号
		子串关系：子串与父串有相同的部分即可
		前缀和后缀：
		！！！注意空串的特殊性
	
	字符串之间有结合律，但没有交换律
	
	字符串看成不变数据类型：
		字符串内容存储：
			存储在一块大的连续区间
			每个字符单独存储
			分段存储
		串结束：
			单独记录长度
			用特殊编码结束
	字符串的替换：
		多次操作完成整个替换
		重叠部分：规定从左到右
		替换后再有重叠的部分应该不要动
		无法预知需要替换部分的个数
	
	
	不同语言中字符串之间的差异：
		字符串可变可不变	python中为不变
		是否有独立的字符类型，python中没有
		基本字符集：python为Unicode
		
		
	python的字符串：
		str -- 不变类型
		长度 -- 其他信息 -- 字符存储区
		
		str的操作：
			获取信息
			构造新str对象
			
		str构造操作：
			简单操作：求长，定位访问
			扫描整个串：O(n)
			
		字符串替换：
			对整个字符串匹配，确定需要匹配的字串的次数和相应的位置
			构造新串过程中动态调整大小
	
	
	字符串匹配：
		模式串 -- 目标串
		
		实际的串匹配问题：
			文本内容大
			模式串大
			时间要求高
			模式串多
	
		串匹配算法：
			逻辑判断
			关键点：
				怎样开始比较字符串
				不匹配后如何操作
				
		
		朴素匹配法：
			从左到右匹配
			发现不匹配，从下一个点开始
			
		KMP算法：
			提前记录字符串的匹配信息 -- 静态预处理
	
	字符串匹配问题：
		模式：
			模式的形式是什么；
			描述的字符串集合如何确定
			怎样做匹配
			
		模式语言 -- 正则表达式（regex）
		
	
	正则表达式：
		原始字符串：在不同字符串前加r或R前缀，反斜杠不作为转义字符
		
	python中re模块的使用：
		re.compile(pattern, flag=0)  -- 生成匹配模式  -- 当一个模式匹配使用的次数多时，则如此操作
		
		re.search(patter, string, flag=0) -- 从任意位置开始匹配，值匹配一次）
		
		re.match(patter, string, flag=0) -- 从头开始匹配，从头开始匹配，仅匹配一次
		
		re.split(pattern, string, maxsplit=(), flags=()) -- 分割字符串，maxsplit最大分割数
		
		re.findall(pattern, string, flags=0) -- 返回一个列表，匹配所有
		
		[\t \v\n\f\r] -- 空白字符
		
		"\^","\-","\]"
		
		
		
		
		
		
			
		
"""