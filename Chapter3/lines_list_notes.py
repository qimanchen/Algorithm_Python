#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
线性表：
	下标
	空表
	表长度
	下一个关系
	顺序关系
	线性关系
	线性结构
	唯一的首元素
	唯一的尾元素
	除首元素，每个元素都有一个前驱元素
	除尾元素，每个元素都有一个后继元素
	实现者：
		如何表示
		如何操作
	使用者：
		提供哪些操作
		如何有效使用
		
	使用者：
		创建数据表，如何提供初始元素序列
		检查表，获取如长度，特定数据，等信息
		改变表：增删 -- 按条件对多个元素同时操作
		多个表之间的操作
		对表中的每个元素操作 - 表的遍历
	变动型 -- 动原表
	非变动型 -- 建新表
		
	表的抽象数据：
		List：
			List(self)		表的构造
			is_empty(self)		判空操作
			len(self)		判断长度
			prepend(self, elem)		插入表首部
			append(self, elem)		插入表尾部
			insert(self, elem, i)		插入指定位置
			del_first(self)		删除第一个元素
			del_last(self)		删除尾元素
			del(self, i)		删除指定位置的元素
			search(self, elem)		查找指定元素
			forall(self, op)		对每个元素进行 op 操作
			
	表数据结构的实现问题：
		计算机内存特点
		保存元素和元素顺序的需要
		各种操作的重要性
	两种实现模型：
		存放在一大块连续存储区 -- 顺序表
		将表元素通过链接存储在一系列存储区中 -- 链接表（链表）
		
顺序表的实现：
	存放在一大块连续存储区，首元素放在开始位置，其他元素依次存储
	
	基本实现方式：
		存储元素类型相同，等距存储
		e_0 地址 + c元素存储大小*i索引值
		类型不同（元素大小不同） -- 外接引用 -- 索引操作 -- 顺序表存储地址
		表的大小会变化
	存储设定：
		确定元素个数 -- 不变顺序表 tuple
		变动表 -- 保留一些空位
		元素的容量和存储个数要单独记录
		
	线性检索：
		逐一比较
	
	不修改表结构的操作模式：
		直接访问 - O(1)
		基于下标循环并检查处理 - O(n)
		
	变动操作：
		尾端插入/删除 - O(1)
		保序指定位置插入/删除 - O(n)
		基于条件删除 - O(n)
		
	顺序表大块连续内存存储：
		优点：
			访问快
		缺点：
			需要大块内存，大小确定
			
	顺序表包含信息：
		元素集合
		实现操作需要的信息
	
	实现方式：
		一体式： 信息和元素在一起  - 不同表对象大小不一
		分离式 -- 需要两个独立对象实现操作 -- 可以实现换存储区 -- 动态顺序表
		
	更换存储区：复杂度变大
		线性增长
		加倍增长 + 尾端插入 -- O(1)
		
	python中list：
		连续表
		分离式
		尾部插入 -- append 效率最高
		建立空表时，建立容纳8个元素的存储区
		满，扩大四倍
		增大倍数 -- 按python解释器
		
		几个操作：
			list.clear()		O(1) -- len设置为0；置换为空表存储区
			list.reverse()		O(n)
			list.sort()		最好的O(nlogn)
			
	顺序表实现线性表：
		定位访问快
		add/delete效率低
		尾端操作效率O(1)
	
	大表不适合顺序表
	
链接表：
	线性表： 元素序列，元素之间顺序关系
	
	用链接关系显示表示元素之间的关系
	
	实现基本想法：
		元素存储在独立存储块中（表节点）
		从任一节点找到它相关的下一节点
		链接的方式表示关联关系
	
	每个结点，可以存储一个和多个元素
	
	数据项+链接域
	
	只需保存首结点的引用 --- 表头指针
	
	空表 -- 表头指针为空连接
	
	空链表 -- 
	
	链表扫描
	
	线性表 - 汇集对象
	
类设计的内在一致性：
	一个类定义了一个整体
	内方法之间需要相互协调，保持一至
	尽量减少复杂程度，和与基类保持一致
	
双向链表：
	牺牲空间代价 -- 对于大容量数据而言是可以接受的

循环双向链表：

线性表反转：
	搬动元素
	改变链接关系
	
链接表的优点：
	表结构容易调整
	通过修改链接关系就可改变其顺序和排列方式
	表小块内存构成
	定位访问需要线性时间
	双向链表可以解决单向链表的删除低效问题
	



		
"""