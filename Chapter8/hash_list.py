#!/usr/bin/env python3
# -*- coding: utf-8 -*-


"""
字典的大数据实现：
	基于散列思想的散列表
	基于各种树形结构的数据存储和检索技术
"""

"""
	散列：
		1、选定一个整数的下标范围，建立一个包括相应元素位置范围的顺序表
		2、选定一个从实际关键码集合到上述下标范围的适当映射h:
			在需要存入关键码key的数据时，将其存入表中第h(key)个位置
			遇到以key为关键码检索数据时，直接去找表中第h(key)个位置的元素
			
		h -- 散列函数，hash函数
		
		从一段可能很长的数据生成一段很短（通常为固定长度）的信息串
		
	应用：
		文件完整性检查
		互联网各种协议认证
		
	采用映射方式带来的其他问题
	
	实现散列表时：
		KEY >> INDEX
		
	冲突：
		不同的关键码映射到同一个h下标，key1和key2 -- 同义词
		
	负载因子 = 散列表中实际数据项数/散列表的基本存储区能容纳的元素个数
	
	权衡
"""

"""
	散列函数：
		确定数据项集合
		选定相应的关键码集合KEY -- 散列函数的参数域
		确定一个存储位置区间INDEX -- 从0开始的一段下标 -- 散列函数的值域
		
	为避免冲突：
		函数应把关键码映射到值域INDEX中尽可能大的部分
		
		不同关键码的散列值在INDEX里均匀分布，有可能减少冲突
		
		函数计算比较简单
		
	设计散列函数的方法：
	
		1、数字分析法
			对于给定的关键码集合，分析所有关键码中各位数字出现频率
			从中选出分布情况较好的若干数字作为散列函数的值
			
			缺点：
				只有关键码集合已知的情况下
		2、折叠法
			将较长的关键码切分为几段，通过某种运算将他们合并
			
		3、中平法
			先求出关键码的平方，然后取出中间的几位作为散列值
			
	
	散列函数的映射关系越乱越好
	设计散列函数，使得得到的结果尽可能没有明显规律
	
	常用散列函数：
		1、除余法 -- 适用于整数关键码
			用key除以某个不大于散列表长度m的整数p，以得到的余数作为散列地址
			m取为2的某个幂值
			
			缺点：相近的关键码将映射到相近的值
		
		2、基数转换法 -- 适用于整数或字符串关键码
			整数：13
				取一个素数作为基数，当取得的关键码不符合时，使用除余等方法实现
				
			字符串：把一个字符看作一个整数，29或31作为基数
			
			对于非整数的的值，将其转换到整数
	
"""

def str_hash(s):
	""" 字符串散列函数"""
	h1 = 0
	for c in s:
		# 29 为选定的基数
		h1 = h1*29 + ord(c)
	return h1
	
"""
	冲突内消解：开地址技术
		内消解  -- 从基本存储区内部解决
		外消解  -- 从外部解决
		
	要求：
		保证当前存入数据项的工作能正常完成
		保证字典的基本存储性质：任何时候，从任何以前存入字典而没有删除的关键码出发，都能找到对应的数据项
		
	开地址法：
		在准备插入数据并发现冲突时，设法在基本存储区里为需要插入的数据另行安排一个位置（还在基本存储区中）
		
		探查方式：
			D建立探查序列 D=d0,d1,d2,...
			Hi = (h(key) + di) mod p    -- p为不超过表长度的数
			
		增量序列：
			1、简单整数序列，0，1，2....	线性探查 
				导致探查序列越来越长，同时冲突越来越多，容易造成堆集的情况产生
			2、设计另一个散列函数h2，令di = i * h2(key) -- 双散列探查
			
	检索和删除：
		检索操作：
			1、调用散列函数，求出key对应的散列地址
			2、检查相应的存储位置，如果该位置没有数据项，就说明这个散列表里不存在相应关键码
			3、否则，比较key于保存在所确定位置的关键码，如果两者匹配则检索以成功结束
			4、否则，根据散列表的探查序列找到下一个地址，并回到步骤2
			
		删除：
			当被删除元素处于其他元素的探查路径上时：
				存入一个特殊标志位
					存入时看作空位
					检索时看作存在元素，执行向下查询
					
	
	外消解技术：
		溢出区：
			当发生冲突时，将相应数据和关键码存入溢出区
			数据在溢出区顺序排列
			检索时，若散列位置的数据与关键码不匹配，就转到溢出区顺序检索
			
			对于冲突项较少可以
			
		桶散列：
			数据项不存放在散列表的基本存储区中，而散列表中存放对数据项的引用
			
			拉链法：
				散列表中每个元素只是一个引用域，引用者保存数据的存储桶
				存储桶就是一个链接的结点表
				
				插入操作：
					先找到散列位置，然后执行插入
					顺序检查
					不允许出项重复的关键码，需要检查整个链表
"""